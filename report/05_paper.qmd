---
title: "Modelo Preditivo de Mortes no Trânsito Brasileiro"
date: 2023-12-19

smooth-scroll: true

authors:
  - name: João Pedro Melani Saraiva
  - name: Pedro Augusto Borges dos Santos

description: "Modelo de aprendizado de máquina orientado a dados de segurança viária para o reconhecimento de padrões e previsão de mortes no trânsito"

title-block-banner: true

format: 
  html:
    editor: source
    dpi: 300
    number-sections: true

knitr: 
  opts_chunk: 
    fig.align: center

bibliography: references.bib
toc: true
toc-title: Sumário

lang: pt
---

```{r include=FALSE}
# packages
library(tidyverse)
library(gt)
library(forecast)
library(ggcorrplot)
library(onsvplot)
library(knitr)
library(here)
library(tidymodels)
library(kableExtra)

# opções de display
options(digits = 2)

# load dos dados
load(here("data","tabela_total.rda"))
load(here("data","tabela_total_mensal.rda"))

# supressão dos warnings
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Introdução

O presente cenário mundial acerca de mortes e lesões relacionadas à sinistros de trânsito posam sérios desafios à saúde pública global, e as tendências evidenciadas pelos dados atuais indicam que esta realidade deve continuar a se manter pelo futuro próximo [@worldhealthorganization2018]. Sendo uma das causas de mortes mais comuns no mundo, as ocorrências de sinistros de trânsito afetam principalmente pedestres, ciclistas e motociclistas, além de induzir danos materiais, tanto em questão de propriedade particular quanto pública. Isto estimula países a buscarem métodos estimativos sobre os efeitos sociais, econômicos e epidemiológicos da taxa de mortes no trânsito e como se traduzem em custos e perdas na produtividade da sociedade em geral [@rodríguez2020].

A segurança viária pode se correlacionar ao estado de desenvolvimento de uma região, visto que é uma característica da mobilidade urbana. Entende-se que as mortes no trânsito dependem de diversos fatores estruturais, socioeconômicos e ambientais [@zhong-xiang2014]. Assim, elevadas taxas de sinistros colaboram no diagnóstico de problemas da segurança pública geral, despertando o debate político sobre a regulamentação das normas viárias e apontando a carência dos sistemas da união em combater estes eventos.

Apesar da crescente adesão por itens de segurança veicular, os sinistros de trânsito permanecem como um problema de saúde pública, visto que fazem parte de um agravo que repercute por toda a sociedade [@andrade2019], sendo a oitava causa de óbitos em todas as faixas etárias e a principal entre indivíduos de 5 a 29 anos [@worldhealthorganization2018]. Como previsto por modelos prévios à 2020 [@blumenberg2018], o Brasil apresentou baixo desempenho em cumprir a meta estabelecida pela Primeira Década de Ações pela Segurança no Trânsito. Neste cenário, o Plano Nacional de Redução de Mortes e Lesões no Trânsito (PNATRANS) foi desenvolvido para guiar as ações pela mobilidade segura nacional durante o período da Segunda Década de Ação pela Segurança no Trânsito [@ministériodostransporte2018], na intenção de aprimorar o desempenho da segurança viária em relação a década passada e se alinhando aos Objetivos de Desenvolvimento Sustentável estabelecidos pela Agenda 2030 da Organização das Nações Unidas (ONU). Para atingir tais metas, o Art. 3º da Resolução Contran Nº 870 relata que o PNATRANS se apoia em seis principais pilares: gestão da segurança no trânsito, vias seguras, segurança veicular, educação para o trânsito, atendimento às vítimas, e normalização e fiscalização [@conselhonacionaldetrânsito2018].

A busca pela fundamentação técnica para a proposição de políticas públicas a respeito da mobilidade segura fomenta o estudo de diversas categorias de modelos preditivos para a mortalidade no trânsito, tanto para estimar o número de ocorrências quanto para avaliar a influência das variáveis consideradas. Modelos lineares multivariados foram ajustados para extrair tendências sobre os critérios aferidos [@blumenberg2018; @cai2015], assim como modelos preditivos baseados em cadeia de Markov [@seneta1996; @jin2020]. Outras abordagens utilizaram técnicas de análise de séries temporais, utilizando métodos como o ARIMA - Modelo Auto-Regressivo Integrado de Médias Móveis [@al-ghamdi1995] e redes neurais artificiais [@jafari2015].

Considerando o presente cenário, este estudo tem como objetivo elaborar um modelo de Aprendizado de Máquina para a previsão de mortes no trânsito em âmbito nacional e estadual no Brasil, investigando dados socioeconômicos como o PIB (Produto Interno Bruto) anual, o PIB mensal e a população nacional, fornecidos respectivamente pelo Instituto Brasileiro de Geografia e Estatística (IBGE) [@institutobrasileirodegeografiaeestatística2023], Banco Central do Brasil (BACEN) [@bancocentraldobrasil2023] e Ministério da Saúde [@ministériodasaúde2023b], tal como dados coletados das bases de dados da Polícia Federal Rodoviária (PRF) [@políciarodoviáriafederal2023], do Registro Nacional de Condutores Habilitados (RENACH) [@ministériodostransporte2023], do Registro Nacional de Veículos Automotores (RENAVAM) [@ministériodostransportes2023] e do Sistema de Informação de Mortalidade (SIM) do Ministério da Saúde [@ministériodasaúde2023a].

A partir de todos os dados reunidos e pré-processados para a modelagem, duas principais análises foram dissertadas para aferir a capacidade preditiva das técnicas em relação a janela temporal estudada: o modelo preditivo anual (por meio de modelo de Regressão Linear) e o modelo preditivo mensal, que por sua vez, pode ser destrinchado em duas abordagens, sendo a análise de série temporal (ARIMA e Suavização Exponencial) e a análise de regressão (Regressão Linear e Regressor Random Forest).

## Modelo Preditivo Anual

### Metodologia

A obtenção dos dados de mortalidade foram efetuados através do pacote `microdatasus` [@microdatasus], elaborado para a linguagem R. Coletou-se dados oriundos do período entre 1996 e 2021. Esta escolha de intervalo temporal visa englobar a mortalidade estimada sob o protocolo da CID-10, pelo qual o banco de dados foi adequado ao estudo extraindo apenas as observações de mortes relacionadas a sinistros, ou seja, aquelas que se encaixam entre os códigos "V01" à "V89".

As demais variáveis foram tratadas e imputadas em uma única tabela:

-   Frota de veículos (RENAVAM);
-   Frota de motocicletas (RENAVAM);
-   Frota de automóveis (RENAVAM);
-   PIB (IBGE);
-   População (DataSUS);
-   Quantidade de sinistros em rodovias federais (PRF);
-   Quantidade de sinistros fatais em rodovias federais (PRF);
-   Feridos em sinistros ocorridos em rodovias federais (PRF);
-   Mortos em sinistros ocorridos em rodovias federais (PRF);
-   Quantidade de condutores habilitados (RENACH).

Em razão da ausência de dados prévios à 2011 de certas fontes, o intervalo de estudo foi reduzido para 2011 a 2021.

Assim sendo, a análise exploratória dos dados (AED) foi produzida para efetivar a validade dos dados e a significância delas para a construção do modelo. É observável que diversas variáveis possuem alto grau de colinearidade entre si, indicando que a modelagem utilizando todos os atributos poderia ser afetada por uma multicolinearidade, assim, podendo resultar em um modelo com baixa performance. A correlação de Spearman foi utilizada e seus resultados estão apresentados à seguir na @fig-corr

```{r}
#| echo: false
#| label: fig-corr
#| fig.cap: Correlograma dos atributos
#| fig.width: 8
#| fig.height: 6
#| fig.dpi: 300

cor_spearman <- df_total |> 
  drop_na() |>
  select(-quilometragem_10_bilhoes) |> 
  cor(method = c("spearman"))

ggcorrplot(
  cor_spearman,
  lab_col = "white",
  type = "lower",
  lab = TRUE, 
  hc.order = T,
  lab_size = 3, 
  tl.srt = 60,
  tl.cex = 12, 
  legend.title = "Correlação",
  colors = c(onsv_palette$blue, "white", onsv_palette$red)
)

```

As variáveis foram avaliadas em relação a sua frequência e densidade. Considerou-se que, em geral, elas possuem comportamentos que devaneiam da normalidade em questão de suas distribuições de probabilidade. Por este motivo, o método mais adequado utilizado para o cálculo dos coeficientes de correlação foi o de Spearman, visto que é uma medida não-paramétrica. Em seguida, cada variável foi testada com um modelo linear, considerando a quantidade de mortes como variável dependente para encontrar seus $p$-valores e métricas de erro quando investigadas individualmente.

Desta forma, a próxima etapa inclui a engenharia dos atributos para a otimização do modelo. O estudo inferencial mostra como diversas variáveis consideradas possuem alta colinearidade, congruente com as relações reais que uma categoria de dado têm com a ocorrência de outro. Por exemplo, a quantidade de mortes em sinistros de trânsito é diretamente correlacionada com a quantidade de sinistros fatais, que por sua vez é correlacionada com a quantidade de sinistros totais. As três variáveis, em adição à quantidade de feridos, estão apresentadas na série temporal da @fig-prf à seguir.

```{r}
#| echo: false
#| label: fig-prf
#| fig.cap: Sinistros e óbitos ocorridos em rodovias federais
#| fig.width: 7
#| fig.height: 5

theme_set(theme_onsv())

df_total %>% 
  select(ano, qnt_acidentes_fatais, qnt_acidentes, qnt_feridos, qnt_mortos) %>%
  pivot_longer(-1, names_to = "variavel", values_to = "n") %>% 
  ggplot(aes(x = ano, y = n, color = variavel)) +
  geom_point(shape = 21, size = 1.5, stroke = 1.5) +
  geom_line(linewidth = 1, alpha = 0.25) +
  labs(x = NULL, y = NULL) +
  scale_x_continuous(limits = c(2007, 2021), breaks = seq(2006, 2021, 1)) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) +
  scale_color_manual(
    labels = c("Sinistros", "Sinistros fatais", "Feridos", "Mortes"),
    values = c(
      onsv_palette$red, 
      onsv_palette$yellow, 
      onsv_palette$blue, 
      onsv_palette$green
    )
  )
```

Outra variável que deve ser analisada individualmente é o número de condutores, que possui uma alta correlação com a população e um comportamento similar em questão da sua contribuição ao modelo. Para verificar se o número de condutores possui um acréscimo homogêneo ao longo do período estudado, calcula-se a quantidade de novos condutores por ano, como visto na @fig-cond, denotando como o ano de 2020 sofreu uma brusca queda de novos indivíduos, possivelmente devido aos impactos da pandemia. Durante a elaboração do modelo, a variável `condutores` apresentou um melhor desempenho que a variável `população`, comparando seus $p$-valores

```{r}
#| echo: false
#| label: fig-cond
#| fig.cap: Número de novos condutores por ano
#| fig.width: 7
#| fig.height: 4

novos_condtrs <- df_total |>
  mutate(novos_condutores = condutores - lag(condutores)) |> 
  select(novos_condutores, condutores, everything())

novos_condtrs |> 
  ggplot(aes(x = ano, y = novos_condutores)) +
    geom_point(
      shape = 21,
      size = 1.5,
      stroke = 1.5,
      color = onsv_palette$blue
    ) +
    geom_line(linewidth = 1, alpha = 0.25, color = onsv_palette$blue) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    scale_x_continuous(breaks = seq(1996, 2022, 1), limits = c(2012,2022)) +
    scale_y_continuous(labels = comma_format(big.mark = ".")) +
    labs(x = NULL, y = NULL)
```

Os atributos altamente colineares de menor influência nas predições foram deletados do conjunto de dados a fim de preservar a capacidade de generalização do modelo, mitigando os efeitos de um possível sobreajuste. A quantidade de mortos em rodovias federais foi considerada uma variável redundante, sendo removida. O PIB, a população e a quantidade de feridos apresentaram desempenho muito inferior, assim foram consideradas menos atuantes na precisão dos resultados e não foram consideradas na elaboração do modelo consolidado.

Após a seleção das variáveis de melhor desempenho, a base de dados foi padronizada a fim de otimizar sua performance e estabilidade no momento de ajuste do modelo. Os coeficientes da regressão linear múltipla estão apresentados à seguir:

```{r}
#| include: false

metricas <- metric_set(rmse, mae, rsq)

df_preprocess <- df_total |> 
  select(
    ano,
    mortes,
    veiculos_total,
    qnt_acidentes_fatais,
    condutores,
    qnt_acidentes,
    populacao
  ) |> 
  drop_na()

lm_recipe <- df_preprocess |> 
  recipe(
    mortes ~
      veiculos_total +
      qnt_acidentes_fatais +
      condutores +
      qnt_acidentes
  ) |>
  step_normalize(all_numeric_predictors())

lm_reg <- linear_reg() |> 
  set_engine("lm")

lm_wflow <- workflow() |> 
  add_recipe(lm_recipe) |> 
  add_model(lm_reg) |> 
  fit(df_preprocess)

coefs <- tidy(lm_wflow) |>
  arrange(p.value)

obs2022 <- list(
  "ano" = 2022,
  "qnt_acidentes" = 64547,
  "qnt_acidentes_fatais" = 4662,
  # "qnt_mortos" = 5439,
  # "qnt_feridos" = 72971,
  "condutores" = 79921178,
  "veiculos_total" = 115116532,
  "populacao" = 203062512
  # "pib" = 9915317
) |> 
  as.data.frame()

df_preprocess_2022 <- bind_rows(df_preprocess, obs2022)

df_pred <- lm_wflow |> 
  predict(df_preprocess_2022) |> 
  cbind(df_preprocess_2022)

df_pred <- lm_wflow |> 
  predict(df_preprocess_2022, type = "conf_int") |> 
  cbind(df_pred) |> 
  mutate(.variation = .pred_upper - .pred_lower)

erros <- metricas(data = df_pred, truth = mortes, estimate = .pred)
```

```{r}
#| echo: false
#| label: tab-coef
#| tbl-cap: Coeficientes resultantes

coefs |>
  rename(Variável = term, Coeficiente = estimate, 'P-valor' = p.value) |> 
  select(-std.error, -statistic) |> 
  mutate(
    Variável = case_match(
      Variável,
      "(Intercept)" ~ "Intercept",
      "qnt_acidentes_fatais" ~ "Sinistros fatais em rodovias federais",
      "veiculos_total" ~ "Frota de veiculos",
      "condutores" ~ "Condutores habilitados",
      "qnt_acidentes" ~ "Sinistros em rodovias federais"
    )
  ) |> 
  mutate(
    Coeficiente = format(Coeficiente, big.mark = ".", decimal.mark = ","),
    `P-valor` = format(round(`P-valor`, 2), decimal.mark = ",")
  ) |> 
  kable(
    align = c("l","r","r"),
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F)
```

### Resultados e Discussão

A redução da disponibilidade de dados tornou inviável a aplicação de técnicas de avaliação de modelo como a separação de conjuntos para treino e teste ou a validação cruzada (*Cross validation*). Por outro lado, a capacidade do algoritmo regressivo pode ser mensurada pelo comparação entre os dados de mortes iniciais com o produto encontrado pelo modelo, conforme apresentado na @fig-reg.

```{r}
#| echo: false
#| label: fig-reg
#| fig.cap: Quantidade de mortes em sinistros de trânsito
#| fig.width: 7
#| fig.height: 4

modelo_linear <- 
  linear_reg() |> 
  set_engine("lm")

mortes_wflow <- 
  workflow() |> 
  add_recipe(lm_recipe) |> 
  add_model(modelo_linear)

mortes_wflow_ajustado <- mortes_wflow |>
 fit(df_total)
  
mortes_previsao <- mortes_wflow_ajustado |>
  predict(df_total) |>
  rename(mortes_pred = .pred)

mortes_previsao <- cbind(df_total, mortes_previsao)

mortes_previsao |> 
  select(mortes, mortes_pred, ano) |> 
  rename(Ano = ano, Previsto = mortes_pred, Real = mortes) |> 
  pivot_longer(
    cols = c(Previsto, Real),
    names_to = "Tipo",
    values_to = "Mortes"
  ) |> 
  ggplot(aes(x = Ano, y = Mortes, color = Tipo)) +
  geom_point(shape = 21, size = 1.5, stroke = 1.5) +
  geom_line(linewidth = 1, alpha = 0.25) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_x_continuous(breaks = seq(1996, 2021, 1)) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) +
  labs(x = NULL, y = NULL) +
  scale_discrete_onsv()
```

O modelo foi utilizado para prever a ocorrência de mortes relacionadas à sinistros de trânsito em 2022, recebendo como *input* os respectivos dados das bases anteriormente consultadas. A predição aponta a tendência anual das mortes, com limites de erro considerados em um intervalo de confiança, conforme apresentado na @fig-pred. O valor previsto para 2022, com base no modelo efetuado, resultou em 33.725 mortes, com um intervalo de confiança entre 31.286 e 36.164 mortes.

```{r}
#| fig.cap: Previsões com intervalo de confiança até 2022
#| echo: false
#| label: fig-pred
#| fig.width: 7
#| fig.height: 5

df_pred |> 
  select(ano, .pred_lower, .pred_upper, .pred, mortes) |> 
  rename(Ano = ano, Previsto = .pred, Real = mortes) |> 
  pivot_longer(
    cols = c(Previsto, Real),
    names_to = "Tipo", 
    values_to = "Mortes"
  ) |> 
  ggplot(aes(x = Ano, y = Mortes)) +
  geom_point(shape = 21, size = 1.5, stroke = 1.5, aes(color = Tipo)) +
  geom_line(linewidth = 1, alpha = 0.25, aes(color = Tipo)) +
  geom_ribbon(
    aes(ymin = .pred_lower, ymax = .pred_upper), 
    fill = "grey",
    alpha = 0.25,
    color = "grey"
  ) +
  scale_x_continuous(breaks = seq(1996, 2022, 1)) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) +
  labs(x = NULL, y = NULL) +
  scale_discrete_onsv()
```

Os métodos selecionados para medir o desempenho do modelo foram a Raiz Quadrada do Erro Médio (*Root Mean Squared Error* - RMSE), o Erro Médio Absoluto (*Mean Squared Error* - MAE) e o R-quadrado - $R^2$. Investigando as métricas de erros com base na comparação do conjunto de dados gerado ao inicial, têm-se:

```{r}
#| echo: false

erros |> 
  select(-.estimator) |> 
  mutate(
    .metric = case_match(
      .metric,
      "rmse" ~ "RMSE",
      "mae" ~ "MAE",
      "rsq" ~ "R²"
    )
  ) |> 
  rename(Métrica = .metric, Valor = .estimate) |> 
  mutate(Valor = format(Valor, decimal.mark = ",")) |> 
  kable(
    caption = "Métricas de Erros", align = c("l","r"), 
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F) |> 
  column_spec(1, width = "6cm", bold = T)
```

Com o valor previsto para 2022, foi possível realizar cálculo das taxas de mortos por 100 mil habitantes e por 10 mil veículos, com o propósito de observar suas tendências. A @fig-hab explicita a crescente taxa de mortes por 100 mil habitantes, apresentando uma estimativa de 16,61 em 2022.

```{r}
#| fig.cap: Mortes por 100.000 habitantes
#| echo: false
#| label: fig-hab
#| fig.width: 7
#| fig.height: 4

taxas_pred <- df_pred |> 
  mutate(
    mortes_100mil_hab = (mortes / populacao) * 100000,
    mortes_10mil_veic = (mortes / veiculos_total) * 10000,
    mortes_100mil_hab_pred = (.pred / populacao) * 100000,
    mortes_10mil_veic_pred = (.pred / veiculos_total) * 10000
  )

taxas_pred |> 
  select(ano, mortes_100mil_hab_pred, mortes_100mil_hab) |> 
  pivot_longer(cols = c(mortes_100mil_hab_pred, mortes_100mil_hab)) |> 
  ggplot(aes(x = ano, y = value, color = name)) +
  geom_point(shape = 21, size = 1.5, stroke = 1.5, aes(color = name)) +
  geom_line(linewidth = 1, alpha = 0.25, aes(color = name)) +
  scale_x_continuous(limits = c(2011, 2022), breaks = seq(1996, 2022, 1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = NULL, y = NULL) +
  scale_color_manual(
    labels = c(
      "Mortes por 100.000 habitantes", 
      "Mortes previstas por 100.000 habitantes"
    ),
    values = c(onsv_palette$yellow, onsv_palette$blue)
  ) +
  geom_label(
    data = taxas_pred |> filter(ano == 2022),
    aes(
      x = ano,
      y = mortes_100mil_hab_pred,
      label = format(mortes_100mil_hab_pred, decimal.mark = ",", digits = 4)
    ),
    color = "gray20",
    vjust = 0,
    nudge_y = 0.20
  )

```

A taxa de mortes por 10 mil veículos resultou em uma previsão de 2,93 em 2022, como mostrada na @fig-veic. O valor representa uma queda em comparação aos anos anteriores, o que pode ser uma consequência do aumento da frota de veículos em relação às mortes no trânsito.

```{r}
#| fig.cap: Mortes por 10.000 veículos
#| echo: false
#| label: fig-veic
#| fig.width: 7
#| fig.height: 4

taxas_pred |>
  select(ano, mortes_10mil_veic_pred, mortes_10mil_veic) |>
  pivot_longer(cols = c(mortes_10mil_veic_pred, mortes_10mil_veic)) |>
  ggplot(aes(x = ano, y = value, color = name)) +
  geom_point(shape = 21, size = 1.5, stroke = 1.5, aes(color = name)) +
  geom_line(linewidth = 1, alpha = 0.25, aes(color = name)) +
  scale_x_continuous(limits = c(2011, 2022), breaks = seq(1996, 2022, 1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = NULL, y = NULL) +
  scale_color_manual(
    labels = c(
      "Mortes por 100.000 habitantes", 
      "Mortes previstas por 100.000 habitantes"
    ),
    values = c(onsv_palette$yellow, onsv_palette$blue)
  ) +
  geom_label(
    data = taxas_pred |> filter(ano == 2022),
    aes(
      x = ano,
      y = mortes_10mil_veic_pred,
      label = format(mortes_10mil_veic_pred, decimal.mark = ",", digits = 3)
    ),
    color = "gray20",
    vjust = 0,
    nudge_y = 0.10
  )
```

A @fig-qq a seguir apresenta uma comparação entre os dados de mortes previstos e reais.

```{r}
#| echo: false
#| label: fig-qq
#| fig.cap: Comparação mortes previstas x reais
#| fig.width: 7
#| fig.height: 5


df_pred |> 
  select(.pred, mortes, ano) |> 
  rename(Previsto = .pred, Real = mortes) |> 
  ggplot(aes(x = Real, y = Previsto)) +
  geom_point(shape = 21, size = 1.5, stroke = 1.5, color = onsv_palette$blue) +
  geom_text(aes(label = ano), vjust = 2, size = 3) + 
  geom_abline(
    linewidth = 1, 
    alpha = 0.5, 
    color = onsv_palette$blue, 
    lty = "dashed"
  ) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) + 
  scale_x_continuous(labels = comma_format(big.mark = ".")) +
  coord_obs_pred()
```

O valor obtido da previsão implica em uma leve queda de 7,4% no número de mortes em relação ao ano anterior (2021), que registrou 33.813 casos. Conforme a análise dos dados, 2021 foi o segundo ano consecutivo a apresentar um aumento em fatalidades no trânsito. O intervalo de confiança mostra como este pode ser o caso de 2022 novamente, não obstante da diminuição prevista para as mortes. Ademais, é notável que, apesar da intensidade das correlações dos preditores selecionados para o estudo, a resolução temporal anual permanece como um gargalo para a análise dos sinistros de trânsito, já que a disponibilidade de dados é limitada.

Retornando ao resultado obtido anteriormente de 33.725 óbitos previstos para 2022, é possível comparar o valor previsto ao valor consolidado real disponibilizado pelo DataSUS em 2024. Foram encontrados 33.894 óbitos, exibindo uma diferença de 169 vítimas esperadas por este modelo.

### Previsões para 2023

A divulgação dos dados consolidados de óbitos em trânsito para 2022 e a atualização das bases de dados do Senatran viabilizam a repaginação do modelo linear anual, passível de uma reestruturação para acomodar os novos dados, com o objetivo de prever o ano de 2023.

Para o treinamento deste modelo, a mesma metodologia é utilizada com a adição dos dados mais atuais. A previsão emitida é apresentada na @fig-pred2023:

```{r}
#| include: false

# limpa ambiente
rm(list = ls(envir = .GlobalEnv))

# carrega dados para análises posteriores
load(here("data","tabela_total.rda"))
load(here("data","tabela_total_mensal.rda"))

# dados atualizados
library(fleetbr)
library(roadtrafficdeaths)
library(arrow)
prf_sinistros <- read_parquet("https://github.com/ONSV/prfdata/releases/download/v0.1.0/prf_sinistros.parquet")
load(here("data","tabela_condutores.rda"))
```

```{r}
#| include: false

dados_modelo_2023 <- list(
  drop_na(count(rename(rtdeaths, ano = ano_ocorrencia), ano, name = "mortes")),
  summarise(filter(fleetbr, modal == "TOTAL", mes == 7), 
            .by = ano, frota = sum(frota)),
  count(filter(prf_sinistros, classificacao_acidente == "Com Vítimas Fatais"), 
        ano, name = "acids_fatais"),
  count(prf_sinistros, ano, name = "acids"),
  tabela_condutores
) |> 
  reduce(full_join, by = "ano") |> 
  arrange(ano)
```

```{r}
#| include=FALSE

rec_anual_2023 <-
  recipe(x = drop_na(dados_modelo_2023), mortes ~ .) |> 
  remove_role(ano, old_role = "predictor") |> 
  step_normalize(all_numeric_predictors())

modelo_anual_2023 <-
  linear_reg() |> 
  set_engine("lm")
  
wflow_anual_2023 <-
  workflow() |> 
  add_model(modelo_anual_2023) |> 
  add_recipe(rec_anual_2023) |> 
  fit(drop_na(dados_modelo_2023))

pred_anual_2023 <- bind_cols(
  dados_modelo_2023,
  predict(wflow_anual_2023, dados_modelo_2023),
  predict(wflow_anual_2023, dados_modelo_2023, type = "conf_int")
)
```

```{r}
#| echo: false
#| label: fig-pred2023
#| fig.cap: Previsão de mortes anuais para 2023
#| fig.width: 7
#| fig.height: 5

pred_anual_2023 |> 
  select(ano, mortes, .pred, .pred_lower, .pred_upper) |> 
  pivot_longer(
    cols = c(.pred, mortes),
    names_to = "Tipo",
    values_to = "Mortes"
  ) |> 
  mutate(
    Tipo = if_else(Tipo == "mortes", "Óbitos reais", "Óbitos previstos")
  ) |> 
  ggplot(aes(ano, Mortes, color = Tipo)) +
    geom_ribbon(
      aes(ymax = .pred_upper, ymin = .pred_lower),
      fill = "grey",
      color = "grey",
      alpha = 0.25
    ) +
    geom_line(linewidth = 1, alpha = 0.25) +
    geom_point(shape = 21, size = 1.5, stroke = 1.5) +
    scale_x_continuous(limits = c(2011,2023), breaks = seq(2011,2023,1)) +
    scale_y_continuous(labels = comma_format(big.mark = ".")) +
    scale_discrete_onsv() + 
    labs(x = NULL, y = NULL)
```

É notável uma brusca diminuição em vítimas previstas em comparação à previsão de 2022, assim como uma dilatação no intervalo de confiança para dados exteriores ao conjunto de ajuste. Este fato implica que o alto desempenho do mesmo modelo em 2022 possa ter sido simplesmente ao acaso, podendo ocasionar em uma valor impreciso para o caso de 2023.

## Modelo Preditivo Mensal

### Metodologia

O modelo preditivo de mortes no trânsito anteriormente criado possuia uma resolução temporal anual que impedia a predição precisa de anos posteriores aos usados para seu ajuste. Visando melhorar o desempenho das predições e atualizar o modelo para uma resolução mensal e estadual, os dados coletados foram reprocessados e novas técnicas foram aplicadas para o estudo das variáveis. Pelo fato de algumas das bases de dados consideradas anteriormente não possuírem disponibilidade da unidade de tempo desejada, os atributos considerados para este estudo foram apenas os seguintes:

-   Frota (RENAVAM);
-   Produto Interno Bruto - PIB (Banco Central do Brasil);
-   Quantidade de sinistros, sinistros fatais e feridos em sinistros ocorridos em rodovias federais (PRF);
-   Mortes em sinistros de trânsito (DATASUS).

A fim de melhor compreender o comportamento destas variáveis em uma resolução temporal maior, as seguintes visualização demonstram a variação de cada atributo considerado conforme o tempo do período disponível para estudo:

::: panel-tabset
#### Frota (RENAVAM)

```{r}
#| echo: false
#| label: fig-tab1
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Dados mensais de frota (RENAVAM)

dados_mensais |> 
  select(data, veiculos, automovel, motocicleta) |>
  rename(
    Veículos = veiculos,
    Automóvel = automovel,
    Motocicleta = motocicleta
  ) |> 
  pivot_longer(-data) |> 
  rename(Anos = data, Modal = name, Frota = value) |> 
  ggplot(aes(x = Anos, y = Frota, color = Modal)) +
  geom_line(linewidth = 1) +
  scale_y_continuous(
    labels = comma_format(big.mark = ".", decimal.mark = ",")
  ) +
  scale_discrete_onsv()
```

#### PIB (BACEN)

```{r}
#| echo: false
#| label: fig-tab2
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Dados mensais de PIB (BACEN)

dados_mensais |> 
  select(data, pib) |> 
  rename(Anos = data, PIB = pib) |> 
  ggplot(aes(x = Anos, y = PIB)) +
  geom_line(linewidth = 1, color = onsv_palette$blue) +
  scale_y_continuous(
    labels = comma_format(big.mark = ".", decimal.mark = ",")
  ) +
  labs(y = "PIB em milhões de dólares")
```

#### Sinistros (PRF)

```{r}
#| echo: false
#| label: fig-tab3
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Dados mensais de sinistros em rodovias federais

dados_mensais |> 
  select(data, acidentes, acidentes_fatais, feridos, mortes_prf) |> 
  rename(
    Anos = data, 
    Sinistros = acidentes, 
   `Sinistros fatais` = acidentes_fatais,
   `Feridos` = feridos,
   `Mortes (PRF)` = mortes_prf
  ) |> 
  pivot_longer(-Anos) |>
  ggplot(aes(x = Anos, y = value, color = name)) +
  geom_line(linewidth = 1) +
  ylab(label = "Número de ocorrências") +
  scale_y_continuous(
    labels = comma_format(big.mark = ".", decimal.mark = ",")
  ) +
  scale_discrete_onsv()
```

#### Mortes (DATASUS)

```{r}
#| echo: false
#| label: fig-tab4
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Dados mensais de mortes em trânsito

dados_mensais |> 
  select(data, mortes) |> 
  rename(Anos = data, Mortes = mortes) |> 
  ggplot(aes(x = Anos, y = Mortes)) +
  geom_line(linewidth =  1, color = onsv_palette$blue) +
  scale_y_continuous(labels = comma_format(big.mark = ".", decimal.mark = ","))
```
:::

#### Análise de Série Temporal

A análise de séries temporais foi efetuada a partir da regressão de um modelo de melhor ajuste sob uma sequência de observações de um evento em um determinado intervalo de tempo de unidades uniformes, sendo estas séries representadas em função do tempo como sua única variável preditora. Entre as vantagens de modelos de série temporal, uma delas é o fato de não necessitarem de outras variáveis e de serem capazes de prever grandes períodos a frente, apesar de serem mais dificilmente ajustadas em comparação a modelos determinísticos convencionais.

##### SARIMA

O primeiro modelo avaliado é o *Seasonal Autoregressive Integrated Moving Average* (SARIMA), uma forma de ARIMA que leva em consideração a sazonalidade da série temporal. Observando a decomposição da série, têm-se as seguintes componentes temporais:

```{r}
#| include: false

load(here("data", "obitos_transito_mensal.rda"))

df_mortes <- obitos_transito_mensal |> 
  mutate(data = ym(paste0(ano,"-",mes))) |> 
  summarise(
    .by = c(data),
    mortes = sum(mortes)
  ) |> 
  drop_na()

rm(obitos_transito_mensal)

ts <- ts(df_mortes$mortes, start = c(1996,1), end = c(2021,12), frequency = 12)
decomposed <- decompose(ts)
```

::: panel-tabset
#### Série Temporal

```{r}
#| echo: false

autoplot(ts, color = onsv_palette$blue, ylab = "Mortes", xlab = "Data")
```

#### Sazonalidade

```{r}
#| echo: false

autoplot(
  decomposed$seasonal,
  color = onsv_palette$blue,
  ylab = "Mortes",
  xlab = "Data"
)
```

#### Tendência

```{r}
#| echo: false

autoplot(
  decomposed$trend,
  color = onsv_palette$blue,
  ylab = "Mortes",
  xlab = "Data"
)
```

#### Residual

```{r}
#| echo: false

autoplot(
  decomposed$random,
  color = onsv_palette$blue,
  ylab = "Mortes",
  xlab = "Data"
)
```
:::

Tradicionalmente, um algoritmo da fámilia ARIMA possui três principais parâmetros: *p*,*d*,*q*, denotando, respectivamente, a ordem do modelo auto-regressivo, o grau de diferenciação necessária e a ordem do modelo de média móvel. Em um modelo de ARIMA sazonal, estes parâmetros podem ser expandidos em uma função ARIMA(*p*,*d*,*q*)(*P*,*D*,*Q*)*m*, onde a segunda parte se refere aos parâmetros da componente sazonal do modelo. Portanto, diversos modelos foram testados e avaliados com variação sobre os hiperparâmetros a fim de encontrar a melhor combinação de valores, sendo este processo automatizado por meio da função `auto.arima()` do pacote `forecast`. A @fig-arima e a @tbl-erarima demonstram a visualização do desempenho do modelo e suas métricas de erro:

```{r}
#| include: false

ts_train <- head(ts, length(ts) - 12)

arima_model <- ts_train |> 
  auto.arima(
    stationary = FALSE,
    seasonal = TRUE
  )

arima_pred <- data.frame(forecast(arima_model, h = 12))

arima_pred <- arima_pred |> 
  mutate(data = my(rownames(arima_pred)))

rownames(arima_pred) <- NULL

arima_df <- full_join(df_mortes, arima_pred)
```

```{r}
#| echo: false
#| label: fig-arima
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Modelo SARIMA

arima_df |> 
  tail(100) |> 
  ggplot(aes(data,mortes)) +
  geom_ribbon(aes(ymin = Lo.80, ymax = Hi.80), fill = "grey60", alpha = 0.75) +
  geom_ribbon(aes(ymin = Lo.95, ymax = Hi.95), fill = "grey80", alpha = 0.75) +
  geom_line(aes(color = "Mortes ocorridas"), linewidth = 1) +
  geom_line(
    aes(y = Point.Forecast, color = "Mortes previstas"),
    linewidth = 1
  ) +
  scale_color_manual(
    name = "Legenda", 
    values = c(
      "Mortes ocorridas" = onsv_palette$blue,
      "Mortes previstas" = onsv_palette$yellow
    )
  ) +
  scale_y_continuous(labels = comma_format(decimal.mark = ",",big.mark = ".")) +
  xlab("Anos") +
  ylab("Mortes")
    
```

```{r}
#| echo: false
#| label: tbl-erarima
#| tbl-cap: Métricas de erro para modelo SARIMA

st_metrics <- metric_set(rmse, rsq)

arima2021 <- sum(arima_df$Point.Forecast, na.rm = T)
truth2021 <- sum(select(drop_na(arima_df), mortes))

st_metrics(arima_df, mortes, Point.Forecast, na_rm = T) |> 
  select(-.estimator) |> 
  mutate(.metric = toupper(.metric)) |> 
  rename(Métrica = .metric, Valor = .estimate) |>
  bind_rows(data.frame("Métrica" = "AIC", "Valor" = arima_model$aic)) |>
  bind_rows(data.frame(
    "Métrica" = "Erro relativo",
    "Valor" = abs(arima2021 - truth2021) / truth2021
  )) |> 
  knitr::kable(table.attr = "quarto-disable-processing=true") |> 
  kableExtra::kable_styling(full_width = F) |> 
  kableExtra::column_spec(1, width = "6cm", bold = T)
```

##### Exponential Smoothing

O modelo de Suavização Exponencial constitui uma família de métodos de análise e previsão de séries temporais mais básicos que os algoritmos de média movel. O método tem como princípio que as predições feitas pelo modelo são simplesmente as médias ponderadas das observações anteriores, tendo seus pesos reduzidos exponencialmente com a passagem do tempo. Os principais tipos de modelos desta categoria são:

-   Suavização Exponencial Simples
-   Suavização Exponencial Dupla (Holt Linear)
-   Suavização Exponencial Tripla (Método Holt-Winters)

Foi utilizado o método de Holt-Winters devido ao fato de ser considerado o mais ideal para tratamento de dados sazonais e não estacionários. A @fig-es e a @tbl-eres demonstram a visualização do desempenho do modelo e suas métricas de erro:

```{r}
#| include: false

es_model <- HoltWinters(ts_train)

es_pred <- data.frame(forecast(es_model, h = 12))

es_pred <- es_pred |> 
  mutate(data = my(rownames(es_pred)))

rownames(es_pred) <- NULL

es_df <- full_join(df_mortes, es_pred)
```

```{r}
#| echo: false
#| label: fig-es
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Modelo de suavização exponencial

es_df |> 
  tail(100) |> 
  ggplot(aes(data,mortes)) +
  geom_ribbon(aes(ymin = Lo.80, ymax = Hi.80), fill = "grey60", alpha = 0.75) +
  geom_ribbon(aes(ymin = Lo.95, ymax = Hi.95), fill = "grey80", alpha = 0.75) +
  geom_line(aes(color = "Mortes ocorridas"), linewidth = 1) +
  geom_line(
    aes(y = Point.Forecast, color = "Mortes previstas"), linewidth = 1
  ) +
  scale_color_manual(
    name = "Legenda", 
    values = c("Mortes ocorridas" = onsv_palette$blue,
    "Mortes previstas" = onsv_palette$yellow)
  ) +
  scale_y_continuous(labels = comma_format(decimal.mark = ",", big.mark = ".")) +
  xlab("Anos") +
  ylab("Mortes")
  
```

```{r}
#| echo: false
#| label: tbl-eres
#| fig.width: 7
#| fig.height: 5
#| tbl-cap: Métricas de erro para modelo de suavização exponencial

es2021 <- sum(es_df$Point.Forecast, na.rm = T)

st_metrics(es_df, mortes, Point.Forecast, na_rm = T) |> 
  select(-.estimator) |> 
  mutate(.metric = toupper(.metric)) |> 
  rename(Métrica = .metric, Valor = .estimate) |>
  bind_rows(
    data.frame(
      "Métrica" = "Erro relativo",
      "Valor" = abs(es2021 - truth2021) / truth2021
    )
  ) |> 
  knitr::kable(table.attr = "quarto-disable-processing=true") |> 
  kableExtra::kable_styling(full_width = F) |> 
  kableExtra::column_spec(1, width = "6cm", bold = T)
```

Baseando-se no modelo de Holt-Winters, pode-se emitir uma previsão até 2030 a fim de analisar o cenário futuro das mortes em trânsito, evidenciando o decaimento da capacidade preditiva deste tipo de modelo ao longo do tempo.

```{r}
#| echo: false
#| label: fig-pred30
#| fig.width: 7
#| fig.height: 4
#| fig.cap: Previsão até 2030 utilizando Exponential Smoothing

es_pred30 <- data.frame(forecast(es_model, h = 120))

es_pred30 <- es_pred30 |> 
  mutate(data = my(rownames(es_pred30)))

rownames(es_pred30) <- NULL

es_df30 <- full_join(df_mortes, es_pred30)

es_df30 |> 
  ggplot(aes(data,mortes)) +
  geom_ribbon(aes(ymin = Lo.80, ymax = Hi.80), fill = "grey60", alpha = 0.75) +
  geom_ribbon(aes(ymin = Lo.95, ymax = Hi.95), fill = "grey80", alpha = 0.75) +
  geom_line(aes(color = "Mortes ocorridas"), linewidth = 1) +
  geom_line(
    aes(y = Point.Forecast, color = "Mortes previstas"), linewidth = 1
  ) +
  scale_color_manual(
    name = "Legenda", 
    values = c("Mortes ocorridas" = onsv_palette$blue,
    "Mortes previstas" = onsv_palette$yellow)
  ) +
  scale_y_continuous(labels = comma_format(decimal.mark = ",", big.mark = ".")) +
  xlab("Anos") +
  ylab("Mortes")
```

#### Modelos Regressores

##### Regressão Linear

A regressão linear múltipla ajustada neste estudo é equivalente ao seu modelo anual predecessor, mas com um número reduzido de variáveis consideradas para treinamento. O correlograma pode ser utilizado novamente para confirmar as correlações lineares entre os atributos:

```{r}
#| echo: false
#| label: fig-corr2
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Correlograma de atributos mensais

ggcorrplot::ggcorrplot(
  corr = cor(select(dados_mensais, -data)),
  type = "lower",
  method = "square",
  lab = TRUE,
  colors = c(onsv_palette$blue, "white", onsv_palette$red)
)
```

Conforme o procedimento de modelagem, a regressão linear é ajustada e representada na @tbl-erlinreg e @fig-linreg:

```{r}
#| include: false

set.seed(123)

split <- initial_split(dados_mensais, prop = 0.8)

train <- training(split)
test <- testing(split)
```

```{r}
#| include: false

rec <-
  recipe(train, mortes ~ .) |> 
  remove_role(c(mortes_prf, data), old_role = "predictor") |> 
  step_normalize(all_numeric_predictors())

lm <-
  linear_reg() |> 
  set_engine("glm")

lm_wflow <-
  workflow() |>
  add_recipe(rec) |> 
  add_model(lm) |> 
  fit(train)

lm_pred <-
  lm_wflow |> 
  predict(test) |> 
  bind_cols(test) |> 
  rename(mortes.pred = .pred)
```

```{r}
#| echo: false
#| label: tbl-erlinreg
#| fig.width: 7
#| fig.height: 5
#| tbl-cap: Métricas de erro para regressão linear mensal

ml_metrics <- metric_set(rmse, mae, rsq)

ml_metrics(lm_pred, truth = mortes, estimate = mortes.pred) |> 
  select(-.estimator) |> 
  mutate(.metric = toupper(.metric)) |> 
  rename(Métrica = .metric, Valor = .estimate) |>
  knitr::kable(table.attr = "quarto-disable-processing=true") |> 
  kableExtra::kable_styling(full_width = F) |> 
  kableExtra::column_spec(1, width = "6cm", bold = T)
```

Em geral, suas métricas apresentaram maior precisão e desempenho em comparação ao modelo anual apesar de se basear em uma quantidade menor de variáveis, obtendo uma maior capacidade preditiva:

```{r}
#| include: false

lm_valid <- 
  lm_wflow |> 
  predict(dados_mensais, type = "conf_int") |> 
  bind_cols(dados_mensais)

lm_valid <-
  lm_wflow |> 
  predict(dados_mensais) |> 
  bind_cols(lm_valid)
```

```{r}
#| echo: false
#| label: fig-linreg
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Modelo de regressão linear mensal

ggplot(lm_valid, aes(x = data, y = mortes)) +
  geom_ribbon(
    aes(ymin = .pred_lower, ymax = .pred_upper),
    fill = "grey70",
    alpha = 0.7
  ) +
  geom_line(aes(color = "Mortes observadas"), linewidth = 1) +
  geom_line(
    aes(y = .pred, color = "Mortes previstas"),
    linewidth = 1
  ) +
  scale_color_manual(values = c(
    "Mortes observadas" = onsv_palette$blue,
    "Mortes previstas" = onsv_palette$yellow)
  ) + 
  scale_y_continuous(labels = comma_format(decimal.mark = ",",big.mark = ".")) +
  xlab("Anos") +
  ylab("Mortes")
```

##### Random Forest

O modelo de regressão por Random Forest foi criado com um número fixo de 5000 árvores de decisão e treinado com a mesma repartição treino-teste utilizada na regressão linear, sendo ajustado e representado na @tbl-errf e @fig-rf. Embora suas métricas apontem desempenhos inferiores em relação ao método linear, o modelo Random Forest teve precisões maiores no ano de 2021.

```{r}
#| include: false

rf <- 
  rand_forest(
    mode = "regression",
    mtry = 5,
    trees = 5000
  ) |> 
  set_engine("ranger")

rf_wflow <-
  workflow() |> 
  add_recipe(rec) |> 
  add_model(rf) |> 
  fit(train)

rf_pred <-
  rf_wflow |> 
  predict(test) |> 
  bind_cols(test)
```

```{r}
#| echo: false
#| label: tbl-errf
#| fig.width: 7
#| fig.height: 5
#| tbl-cap: Métricas de erro para modelo Random Forest

ml_metrics(rf_pred, truth = mortes, estimate = .pred) |> 
  select(-.estimator) |> 
  mutate(.metric = toupper(.metric)) |> 
  rename(Métrica = .metric, Valor = .estimate) |>
  knitr::kable(table.attr = "quarto-disable-processing=true") |> 
  kableExtra::kable_styling(full_width = F) |> 
  kableExtra::column_spec(1, width = "6cm", bold = T)
```

A sobressaliência do modelo linear em relação ao Random Forest é possivelmente devido:

-   Às altas correlações lineares e covariâncias entre as variáveis;
-   Ao número de árvores (hiperparâmetro não otimizado) e ou;
-   Ao sobreajuste.

```{r}
#| include: false

rf_valid <-
  rf_wflow |> 
  predict(dados_mensais) |>
  bind_cols(dados_mensais)
```

```{r}
#| echo: false
#| label: fig-rf
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Modelo Random Forest

ggplot(rf_valid, aes(x = data, y = mortes)) +
  geom_line(aes(color = "Mortes observadas"), linewidth = 1) +
  geom_line(aes(y = .pred, color = "Mortes previstas"), linewidth = 1) +
  scale_color_manual(values = c(
    "Mortes observadas" = onsv_palette$blue,
    "Mortes previstas" = onsv_palette$yellow
  )) + 
  scale_y_continuous(labels = comma_format(decimal.mark = ",",big.mark = ".")) + 
  xlab("Anos") +
  ylab("Mortes")
```

### Resultados e Discussão

Após a avaliação individual de cada modelo, nota-se que diversas métricas de erros utilizadas são não normalizadas, necessitando, portanto, de uma análise comparativa do desempenho de cada técnica em relação às demais. A tabela a seguir apresenta as métricas para cada algoritmo utilizado até então, o que auxiliará na escolha de um modelo definitivo:

```{r}
#| include: false

format_metrics <- function(df,name_model = "none") {
  res <- df |> 
    select(-.estimator) |>
    mutate(.metric = toupper(.metric),
           Modelo = name_model) |>
    rename(Métrica = .metric,
           Valor = .estimate)
  
  return(res)
}

tbl_metrics1 <- format_metrics(ml_metrics(rf_pred,mortes,.pred),"RF Mensal")
tbl_metrics2 <- format_metrics(ml_metrics(lm_pred,mortes,mortes.pred),"Linear Mensal")
tbl_metrics3 <- format_metrics(erros, "Linear Anual")
tbl_metrics4 <- format_metrics(st_metrics(arima_df,mortes,Point.Forecast),"SARIMA")
tbl_metrics5 <- format_metrics(st_metrics(es_df,mortes,Point.Forecast),"Exponential Smoothing")
```

```{r}
#| echo: false
#| label: tbl-ertotal
#| fig.width: 7
#| fig.height: 5
#| tbl-cap: Tabela de métricas para todos os modelos

bind_rows(tbl_metrics1,tbl_metrics2,tbl_metrics3,tbl_metrics4,tbl_metrics5) |> 
  pivot_wider(names_from = Métrica, values_from = Valor) |>  
  mutate(`Tipo de modelo` = case_when(
    grepl("RF|Linear",Modelo) ~ "Determinístico",
    .default = "Série Temporal"
  )) |>
  group_by(`Tipo de modelo`) |> 
  gt() |> 
  tab_header("Métricas de Erros") |> 
  fmt_number(columns = c(RMSE,MAE,RSQ),
             sep_mark = ".",
             dec_mark = ",") |> 
  sub_missing(missing_text = '-') |>
  tab_options(column_labels.background.color = onsv_palette$blue,
              column_labels.font.weight = "bold") |> 
  tab_style(style = cell_text(color = onsv_palette$blue),
            locations = cells_title()) |> 
  tab_style(style = cell_text(align = "center"),
            locations = cells_column_labels()) 
  
```

Conforme a @tbl-ertotal e os gráficos da @fig-rf e @fig-linreg, os modelos de Regressão Linear e Random Forest mensais possuem os melhores valores de perfomance entre os métodos contemplados pelo presente estudo, com o modelo linear apresentando resultados ligeiramente superiores aos do Random Forest em geral, embora o último tenho se sobressaído ao prever as mortes de 2021 com maior exatidão, possivelmente ao acaso.

O modelo linear mensal pode ser utilizado para exemplificar os resultados preliminares para o ano de 2022, conforme denota a @fig-lmpred2022, assim como foi feito com o modelo linear anual. As predições produzidas totalizam 35.379 mortes neste ano, com um aumento previsto de 1.566 (4,4%) em relação a 2011. Comparado ao modelo linear anual, o modelo mensal aparenta ser menos preciso na previsão de anos inteiros, sendo possivelmente mais adequado apenas para o monitoramento mensal.

```{r}
#| echo: false
#| label: fig-lmpred2022
#| fig.width: 7
#| fig.height: 5
#| fig.cap: Previsões para 2022 com modelo linear

load(here("data","frota_mensal.rda"))
load(here("data","obitos_transito_mensal.rda"))
load(here("data","pib_mensal.rda"))
load(here("data","sinistros_prf_mensal.rda"))

frota_2022 <- frota_mensal |> 
  pivot_wider(names_from = modal, values_from = frota) |> 
  mutate(
    data = ym(paste0(ano,"-",mes)),
    automovel = AUTOMOVEL, CAMINHONETE, CAMIONETA, UTILITARIO,
    motocicleta = MOTOCICLETA, CICLOMOTOR, MOTONETA
  ) |> 
  rename(total = TOTAL) |> 
  summarise(
    .by = data,
    total = sum(total),
    automovel = sum(automovel),
    motocicleta = sum(motocicleta)
  )

mortes_2022 <- obitos_transito_mensal |> 
  select(-uf) |> 
  drop_na() |> 
  mutate(data = ym(paste0(ano,"-",mes))) |> 
  summarise(
    .by = data,
    mortes = sum(mortes)
  )

pib_2022 <- pib_mensal |> 
  mutate(data = ym(paste0(ano,"-",mes))) |> 
  select(data, pib)

prf_2022 <- sinistros_prf_mensal |> 
  mutate(data = ym(paste0(ano,"-",mes))) |> 
  summarise(
    .by = data,
    acidentes = sum(acidentes),
    acidentes_fatais = sum(acidentes_fatais),
    feridos = sum(feridos),
    mortes_prf = sum(mortes)
  )

dados_mensais_2022 <- reduce(
  list(frota_2022, mortes_2022, pib_2022, prf_2022),
  full_join,
  by = "data"
) |> 
  rename(veiculos = total) |> 
  filter(year(data) %in% seq(2011,2022,1))

pred_mensal_2022 <- bind_cols(
  dados_mensais_2022,
  predict(lm_wflow, dados_mensais_2022),
  predict(lm_wflow, dados_mensais_2022, type = "conf_int")
) 

pred_mensal_2022 |> 
  ggplot(aes(data, mortes)) +
    geom_ribbon(aes(ymax = .pred_upper, ymin = .pred_lower), 
                fill = "gray70", alpha = 0.7) +
    geom_line(aes(color = "Mortes observadas"), linewidth = 1) +
    geom_line(aes(y = .pred, color = "Mortes previstas"), linewidth = 1) +
    scale_color_manual(values = c(
      "Mortes previstas" = onsv_palette$yellow,
      "Mortes observadas" = onsv_palette$blue
    )) +
    scale_y_continuous(labels = comma_format(decimal.mark = ",",big.mark = ".")) +
    xlab("Anos") +
    ylab("Mortes")
```

Neste sentido, a @tbl-totpred2022 representa os valores totais estimados para o ano de 2022 de cada modelo contemplado até o momento, junto com intervalos de confiança previstos por cada algoritmo. Vale destacar que o modelo Random Forest, que anteriormente teria tido métricas ligeiramente inferiores ao modelo linear mensal, obteve um valor mais próximo ao linear anual. Isto aponta que este modelo pode ser o mais adequado para estipulações temporais de curto prazo.

```{r}
#| echo: false
#| label: tbl-totpred2022
#| fig-width: 7
#| fig-height: 5
#| tbl-cap: Tabela de previsões para 2022

# total arima 2022
total_arima_2022 <- data.frame(forecast(arima_model, h = 24))
total_arima_2022 <- total_arima_2022 |> 
  mutate(data = my(rownames(total_arima_2022)))
rownames(total_arima_2022) <- NULL
total_arima_2022 <- total_arima_2022 |> 
  filter(year(data) == 2022) |> 
  select(Point.Forecast, Lo.95, Hi.95) |> 
  mutate_all(sum) |> 
  first() |> 
  rename(pred = Point.Forecast, lower = Lo.95, upper = Hi.95)

# total exponential smoothing 2022
total_es_2022 <- data.frame(forecast(es_model, h = 24))
total_es_2022 <- total_es_2022 |> 
  mutate(data = my(rownames(total_es_2022)))
rownames(total_es_2022) <- NULL
total_es_2022 <- total_es_2022 |> 
  filter(year(data) == 2022) |> 
  select(Point.Forecast, Lo.95, Hi.95) |> 
  mutate_all(sum) |> 
  first() |> 
  rename(pred = Point.Forecast, lower = Lo.95, upper = Hi.95)

# total anual 2022
total_lm_anual_2022 <- df_pred |> 
  filter(ano == 2022) |> 
  select(.pred, .pred_lower, .pred_upper) |> 
  rename(pred = .pred, lower = .pred_lower, upper = .pred_upper)

# total linear mensal 2022
total_lm_mensal_2022 <- pred_mensal_2022 |> 
  filter(year(data) == 2022) |> 
  select(.pred, .pred_lower, .pred_upper) |> 
  mutate_all(sum) |> 
  first() |> 
  rename(pred = .pred, lower = .pred_lower, upper = .pred_upper)

# total rf mensal 2022
total_rf_mensal_2022 <- bind_cols(
  dados_mensais_2022,
  predict(rf_wflow, dados_mensais_2022)
) |> 
  filter(year(data) == 2022) |> 
  select(.pred) |> 
  mutate_all(sum) |> 
  first() |> 
  rename(pred = .pred) |> 
  mutate(lower = NA, upper = NA)

# tabela de predições 2022
bind_rows(
  total_arima_2022, 
  total_es_2022, 
  total_lm_anual_2022,
  total_lm_mensal_2022, 
  total_rf_mensal_2022
) |> 
  mutate(Modelo = c("SARIMA", "Exponential Smoothing", 
                    "Linear Anual", "Linear Mensal",
                    "Random Forest Mensal")) |> 
  relocate(Modelo) |> 
  rename(Previsão = pred, `Limite Máx.` = upper, `Limite Mín.` = lower) |> 
  gt() |> 
  tab_header("Previsões para 2022") |> 
  fmt_integer(columns = c(Previsão,`Limite Mín.`,`Limite Máx.`),
             sep_mark = ".") |>
  tab_options(column_labels.background.color = onsv_palette$blue,
              column_labels.font.weight = "bold") |> 
  tab_style(style = cell_text(color = onsv_palette$blue),
            locations = cells_title()) |> 
  tab_style(style = cell_text(align = "center"),
            locations = cells_column_labels()) |> 
  sub_missing(missing_text = "-") |> 
  tab_footnote(
    footnote = "Algoritmo não produz intervalo de confiança",
    locations = cells_body(columns = Modelo,
                           rows = Modelo == "Random Forest Mensal"),
    placement = "left"
  )
```

## Conclusão

Os modelos regressivos desenvolvidos permitem inferir que há uma tendência perceptível nas mortes causadas pelo trânsito. Mesmo que as previsões do primeiro método demonstrem que há a possibilidade de redução no ano subsequente, é visível que a predição do modelo linear anual ajustado está significativamente distante da quantidade de casos do ano de 2019, quando houve a maior redução do número de mortos desde o seu pico em 2012. Ademais, ambos os modelos mensais determinísticos e de séries temporais indicam um aumento na tendência das mortes. Isto revela um potencial relaxamento no desempenho do sistema de segurança viária e mobilidade segura nacional, visto que esta possível queda em sua eficiência precipitaria o aumento da mortalidade em sinistros de trânsito.

É fundamental destacar que as soluções de segurança viária não dependem apenas de atributos da mobilidade urbana. Inúmeros fatores socioeconômicos e de infraestrutura afetam o desempenho da segurança, indiretamente variando com as condições de desenvolvimento e maturidade tecnológica da região em questão. A mobilidade urbana é uma parte integral à toda civilização moderna, o que torna as ações para a segurança viária indispensáveis.

O cenário atual da segurança viária brasileira apresenta alguns desafios e deficiências que podem impactar na conquista das metas de redução estabelecidas em âmbito nacional pelo PNATRANS. Os dados previstos mostram um desempenho abaixo do ideal no combate da mortalidade, conferindo uma perspectiva pessimista para o início da nova década no Brasil e, caso este cenário não seja amenizado com antecedência, é improvável a ocorrência de avanços significativos nos objetivos da Segunda Década de Ação pela Segurança no Trânsito.

## Referências
