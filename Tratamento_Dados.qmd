---
title: "Tratamento_Dados"
format: 
  html:
    execute:
      warning: false
editor: visual
---

- Colocar o carregamento de pacotes na mesma célula

```{r}
library(tidyverse)
library(microdatasus)
library(obsplot)
library(knitr)
```

# Dados de mortes no trânsito (DATASUS)

Aqui eu apliquei um método para não precisar baixar os dados do DATASUS toda hora que for compilar o documento. A função `save()` salva qualquer objeto do R em um arquivo binário do formado `.rda`. Assim, é só usar o `load()` para carregar novamente os dados. Assim, apliquei uma condicional para verificar se o arquivo já existe dentro da pasta `data/` (`file.exists()`). Caso sim, ele carrega com o `load()`, caso não, ele faz todo o processo do `microdatasus` com o `fetch_datasus`.

```{r}

if (file.exists("data/datasus.rda")) {
  load("data/datasus.rda")
} else {
  df_datasus <- fetch_datasus(
    year_start = 1996,
    year_end = 2021,
    information_system = "SIM-DOEXT",
    vars = c("DTOBITO","CAUSABAS")
  )

  save(df_datasus, file = "data/datasus.rda")
}

```

```{r}
head(df_datasus)
```

- Sempre colocar espaço depois da vírgula; também antes e depois do `=`

- Não deixe a linha passar de 80 caracteres

- Usar o `head()` para não carregar tanta informação no terminal / notebook

- Usar o `kable()` do pacote `knitr` para renderizar uma tabela mais bonita no documento final

```{r}
st_datasus <- df_datasus |> 
  # filter(str_detect(CAUSABAS,paste(paste0("V",seq(0,8,1)),collapse="|"))) |> 
  filter(
    str_detect(CAUSABAS, paste(paste0("V", seq(0, 8, 1)), collapse = "|"))
  ) |> 
  mutate(
    datas = as.character(DTOBITO),
    ano = as.numeric(str_sub(datas, -4, -1))
  )

# st_datasus
knitr::kable(head(st_datasus))
```

- Aqui tem como substituir o `group_by()` + `summarise()` pelo `count()`

- Usei o `as_tibble()` para transformar o `data.frame` no formato padrão do tidyverse

```{r}
obitos_ano <- st_datasus |> 
  # group_by(ano) |> 
  # summarise(
  #   obitos = n()
  # )
  count(ano, name = "obitos") |> 
  as_tibble()

kable(obitos_ano)
```

- Coloquei o carregamento do obsplot no começo do projeto

- Apliquei umas correções no estilo de escrita:

  - Espaçamento: espaços depois da vírgula e ao redor dos `=`

  - GGplot: cada elemento / objeto deve ficar individualmente em uma linha

- Ajustei o título

```{r}
#library(obsplot)

# ggplot(obitos_ano,aes(x = ano, y = obitos)) +
#   geom_point() + geom_line() + #objetos geométricos
#   scale_x_continuous(breaks = seq(1996,2021,1)) + scale_y_continuous(limits = c(0,NA)) + #escala
#   theme_obs() + theme(axis.text.x = element_text(angle=45,vjust=1,hjust=1)) + #tema
#   ggtitle("Mortes por ano DATASUS")

ggplot(obitos_ano, aes(x = ano, y = obitos)) +
  geom_point() +
  geom_line() +
  scale_x_continuous(breaks = seq(1996, 2021, 1)) +
  scale_y_continuous(limits = c(0, NA)) +
  theme_obs() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Mortes no Trânsito Brasileiro")
```

# Sinistros em rodovias federais (PRF)

- Aqui também eu ajustei o tamanho da linha (limite de 80 caracteres)

```{r}
datatran2007 <- read_csv2(
  "datatran/datatran2007/datatran2007.csv", 
  locale = locale(encoding = "latin1")
)
kable(head(datatran2007))
```

```{r}
acidentes2007 <- datatran2007 |> 
  select (
    data_inversa,
    mortos,
    feridos,
    classificacao_acidente
  ) |> 
  mutate(
    ano = as.numeric(str_sub(data_inversa,-4,-1)),
    classificacao_acidente = case_when(
      classificacao_acidente %in% c("(null)","Ignorado") & mortos > 0 ~ "Com Vítimas Fatais",
      classificacao_acidente %in% c("(null)","Ignorado") & mortos == 0 & feridos > 0 ~ "Com Vítimas Feridas",
      classificacao_acidente %in% c("(null)","Ignorado") & mortos == 0 & feridos == 0 ~ "Sem Vítimas",
      TRUE ~ classificacao_acidente
    )
  )

acidentes2007 |> 
  select(
    classificacao_acidente
  ) |> 
  unique()

```

```{r}
mortes2007 <- acidentes2007 |> 
  group_by(ano) |> 
  summarise(
    qnt_acidentes = n(),
    qnt_acidentes_fatais = sum(classificacao_acidente == "Com Vítimas Fatais"),
    qnt_feridos = sum(feridos),
    qnt_mortos = sum(mortos)
    )

mortes2007
```

```{r}
#criação da função

datatran_extract <- function(df) {

  acidentes <- df |> 
  select (
    data_inversa,
    mortos,
    feridos,
    classificacao_acidente
  ) |> 
  mutate(
    
    ano = case_when(
      is.character(data_inversa) ~ year(dmy(data_inversa)),
      !is.character(data_inversa) ~ year(data_inversa)
    ),
    
    classificacao_acidente = case_when(
      classificacao_acidente %in% c("(null)","Ignorado",NA) & mortos > 0 ~ "Com Vítimas Fatais",
      classificacao_acidente %in% c("(null)","Ignorado",NA) & mortos == 0 & feridos > 0 ~ "Com Vítimas Feridas",
      classificacao_acidente %in% c("(null)","Ignorado",NA) & mortos == 0 & feridos == 0 ~ "Sem Vítimas",
      TRUE ~ classificacao_acidente
    )
  )
  
  mortes <- acidentes |> 
  group_by(ano) |> 
  summarise(
    qnt_acidentes = n(),
    qnt_acidentes_fatais = sum(classificacao_acidente == "Com Vítimas Fatais"),
    qnt_feridos = sum(feridos),
    qnt_mortos = sum(mortos)
  )
  
  return(mortes)

}

#testando a função

testes <- datatran_extract(datatran2007)

testes

```

- Ajuste de espaçamento no `if`

- Deletei o `print()`, não é necessário

```{r}
#criação de loop para a importação de todos os anos

k <- seq(2007, 2021, 1)
enderecos <- paste("datatran/datatran", k ,"/datatran", k, ".csv", sep = "")

# df_temp1 <- read_csv2(enderecos[1], locale = locale(encoding = "latin1")) |> datatran_extract()


if ("datatran_anos" |> exists()) {
  rm("datatran_anos")
}

for (i in enderecos) {
  df_temp <- read_csv2(i, locale = locale(encoding = "latin1")) |>
    datatran_extract()
  if(exists("datatran_anos")){
    datatran_anos <- bind_rows(datatran_anos, df_temp)
  }
  else{
    datatran_anos <- df_temp
  }
}

datatran_anos |> kable()
```

```{r}

import1 <- read_csv2(enderecos[7], locale = locale(encoding = "latin1"))
process1 <- datatran_extract(import1)

view(import1)

import1$data_inversa |> year()

import1|> filter_all(is.na)
```